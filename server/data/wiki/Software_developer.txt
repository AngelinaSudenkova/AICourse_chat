Software development Creation and maintenance of software Part of a series on Software development Core activities Data modeling Processes Requirements Design Construction Engineering Testing Debugging Deployment Maintenance Paradigms and models Agile Cleanroom Incremental Prototyping Spiral V model Waterfall Methodologies and frameworks ASD DAD DevOps DSDM FDD IID Kanban Lean SD LeSS MDD MSF PSP RAD RUP SAFe Scrum SEMAT TDD TSP UP XP Supporting disciplines Configuration management Deployment management Documentation Project management Quality assurance User experience Practices ATDD BDD CCO CD CI DDD PP SBE Stand-up TDD Tools Build automation Compiler Debugger GUI builder IDE Infrastructure as code Profiler Release automation UML Modeling Standards and bodies of knowledge CMMI IEEE standards IREB ISO 9001 ISO/IEC standards ITIL OMG PMBOK SWEBOK Glossaries Artificial intelligence Computer science Electrical and electronics engineering Outlines Software development C programming language C sharp programming language C++ programming language Java programming language JavaScript programming language Python programming language Rust programming language v t e Software development is the process of designing, creating, testing, and maintaining software applications to meet specific user needs or business objectives . The process is more encompassing than programming , writing code , in that it includes conceiving the goal, evaluating feasibility, analyzing requirements , design , testing and release . The process is part of software engineering which also includes organizational management , project management , configuration management and other aspects. [ 1 ] Software development involves many skills and job specializations including programming , testing , documentation , graphic design , user support , marketing , and fundraising . Software development involves many tools including: compiler , integrated development environment (IDE), version control , computer-aided software engineering , and word processor. The details of the process used for a development effort vary. The process may be confined to a formal, documented standard , or it can be customized and emergent for the development effort. The process may be sequential, in which each major phase (i.e., design, implement, and test) is completed before the next begins, but an iterative approach – where small aspects are separately designed, implemented, and tested – can reduce risk and cost and increase quality. Methodologies Main article: Software development methodology Flowchart of the evolutionary prototyping model , an iterative development model [ 2 ] Each of the available methodologies is best suited to specific kinds of projects, based on various technical, organizational, project, and team considerations. [ 3 ] The simplest methodology is the "code and fix", typically used by a single programmer working on a small project. After briefly considering the purpose of the program, the programmer codes it and runs it to see if it works. When they are done, the product is released. This methodology is useful for prototypes but cannot be used for more elaborate programs. [ 4 ] In the top-down waterfall model , feasibility, analysis, design , development, quality assurance , and implementation occur sequentially in that order. This model requires one step to be complete before the next begins, causing delays, and makes it impossible to revise previous steps if necessary. [ 5 ] [ 6 ] [ 7 ] With iterative processes these steps are interleaved with each other for improved flexibility, efficiency, and more realistic scheduling. Instead of completing the project all at once, one might go through most of the steps with one component at a time. Iterative development also lets developers prioritize the most important features, enabling lower priority ones to be dropped later on if necessary. [ 6 ] [ 8 ] Agile is one popular method, originally intended for small or medium sized projects, that focuses on giving developers more control over the features that they work on to reduce the risk of time or cost overruns. [ 9 ] Derivatives of agile include extreme programming and Scrum . [ 9 ] Open-source software development typically uses agile methodology with concurrent design, coding, and testing, due to reliance on a distributed network of volunteer contributors. [ 10 ] Beyond agile, some companies integrate information technology (IT) operations with software development, which is called DevOps or DevSecOps including computer security . [ 11 ] DevOps includes continuous development, testing , integration of new code in the version control system, deployment of the new code, and sometimes delivery of the code to clients. [ 12 ] The purpose of this integration is to deliver IT services more quickly and efficiently. [ 11 ] Another focus in many programming methodologies is the idea of trying to catch issues such as security vulnerabilities and bugs as early as possible ( shift-left testing ) to reduce the cost of tracking and fixing them. [ 13 ] In 2009, it was estimated that 32% of software projects were delivered on time and on budget, and with full functionality. An additional 44% were delivered, but were missing at least one of their features. The remaining 24% were cancelled before release. [ 14 ] Steps Software development life cycle refers to the systematic process of developing applications . [ 15 ] Feasibility The sources of ideas for software products are plentiful. These ideas can come from market research , including the demographics of potential new customers, existing customers, sales prospects who rejected the product, other internal software development staff, or a creative third party. Ideas for software products are usually first evaluated by marketing personnel for economic feasibility, fit with existing channels of distribution, possible effects on existing product lines, required features , and fit with the company's marketing objectives. In the marketing evaluation phase, the cost and time assumptions are evaluated. [ 16 ] The feasibility analysis estimates the project's return on investment , its development cost and timeframe. Based on this analysis, the company can make a business decision to invest in further development. [ 17 ] After deciding to develop the software, the company is focused on delivering the product at or below the estimated cost and time, and with a high standard of quality (i.e., lack of bugs) and the desired functionality. Nevertheless, most software projects run late, and sometimes compromises are made in features or quality to meet a deadline. [ 18 ] Analysis Software analysis begins with a requirements analysis to capture the business needs of the software. [ 19 ] Challenges for the identification of needs are that current or potential users may have different and incompatible needs, may not understand their own needs, and change their needs during the process of software development. [ 20 ] Ultimately, the result of analysis is a detailed specification for the product that developers can work from. Software analysts often decompose the project into smaller objects, components that can be reused for increased cost-effectiveness, efficiency, and reliability. [ 19 ] Decomposing the project may enable a multi-threaded implementation that runs significantly faster on multiprocessor computers. [ 21 ] During the analysis and design phases of software development, structured analysis is often used to break down the customer's requirements into pieces that can be implemented by software programmers. [ 22 ] The underlying logic of the program may be represented in data-flow diagrams , data dictionaries , pseudocode , state transition diagrams , and/or entity relationship diagrams . [ 23 ] If the project incorporates a piece of legacy software that has not been modeled, this software may be modeled to help ensure it is correctly incorporated with the newer software. [ 24 ] Design Main article: software design Design involves choices about the implementation of the software, such as which programming languages and database software to use, or how the hardware and network communications will be organized. Design may be iterative with users consulted about their needs in a process of trial and error . Design often involves people who are expert in aspects such as database design , screen architecture, and the performance of servers and other hardware. [ 19 ] Designers often attempt to find patterns in the software's functionality to spin off distinct modules that can be reused with object-oriented programming . An example of this is the model–view–controller , an interface between a graphical user interface and the backend . [ 25 ] Programming Main article: computer programming The central feature of software development is creating and understanding the software that implements the desired functionality. [ 26 ] There are various strategies for writing the code. Cohesive software has various components that are independent from each other. [ 19 ] Coupling is the interrelation of different software components, which is viewed as undesirable because it increases the difficulty of maintenance . [ 27 ] Often, software programmers do not follow industry best practices, resulting in code that is inefficient, difficult to understand, or lacking documentation on its functionality. [ 28 ] These standards are especially likely to break down in the presence of deadlines. [ 29 ] As a result, testing, debugging, and revising the code become much more difficult. Code refactoring , for example, adding more comments to the code, is a solution to improve the understandability of the code. [ 30 ] Testing Main article: software testing Testing is the process of ensuring that the code executes correctly and without errors. Debugging is performed by each software developer on their own code to confirm that the code does what it is intended to. In particular, it is crucial that the software executes on all inputs, even if the result is incorrect. [ 31 ] Code reviews by other developers are often used to scrutinize new code added to the project, and according to some estimates dramatically reduce the number of bugs persisting after testing is complete. [ 32 ] Once the code has been submitted, quality assurance – a separate department of non-programmers for most large companies – test the accuracy of the entire software product. Acceptance tests derived from the original software requirements are a popular tool for this. [ 31 ] Quality testing also often includes stress and load checking (whether the software is robust to heavy levels of input or usage), integration testing (to ensure that the software is adequately integrated with other software), and compatibility testing (measuring the software's performance across different operating systems or browsers). [ 31 ] When tests are written before the code, this is called test-driven development . [ 33 ] Production See also: Software release life cycle Production is the phase in which software is deployed to the end user. [ 34 ] During production, the developer may create technical support resources for users [ 35 ] [ 34 ] or a process for fixing bugs and errors that were not caught earlier. There might also be a return to earlier development phases if user needs changed or were misunderstood. [ 34 ] Workers Software development is performed by software developers , usually working on a team. Efficient communications between team members is essential to success. This is more easily achieved if the team is small, used to working together, and located near each other. [ 36 ] Communications also help identify problems at an earlier stage of development and avoid duplicated effort. Many development projects avoid the risk of losing essential knowledge held by only one employee by ensuring that multiple workers are familiar with each component. [ 37 ] Software development involves professionals from various fields, not just software programmers but also product managers who set the strategy and roadmap for the product, [ 38 ] individuals specialized in testing, documentation writing, graphic design , user support, marketing , and fundraising. Although workers for proprietary software are paid, most contributors to open-source software are volunteers. [ 39 ] Alternately, they may be paid by companies whose business model does not involve selling the software, but something else – such as services and modifications to open source software. [ 40 ] Models and tools Computer-aided software engineering Computer-aided software engineering (CASE) is tools for the partial automation of software development. [ 41 ] CASE enables designers to sketch out the logic of a program, whether one to be written, or an already existing one to help integrate it with new code or reverse engineer it (for example, to change the programming language ). [ 42 ] Documentation Main article: Software documentation Documentation comes in two forms that are usually kept separate – one intended for software developers, and another made available to the end user to help them use the software. [ 43 ] [ 44 ] Most developer documentation is in the form of code comments for each file, class , and method that cover the application programming interface (API)—how the piece of software can be accessed by another—and often implementation details. [ 45 ] This documentation is helpful for new developers to understand the project when they begin working on it. [ 46 ] In agile development, the documentation is often written at the same time as the code. [ 47 ] User documentation is more frequently written by technical writers . [ 48 ] Effort estimation Main article: Software development effort estimation Accurate estimation is crucial at the feasibility stage and in delivering the product on time and within budget. The process of generating estimations is often delegated by the project manager . [ 49 ] Because the effort estimation is directly related to the size of the complete application, it is strongly influenced by the addition of features in the requirements—the more requirements, the higher the development cost. Aspects not related to functionality, such as the experience of the software developers and code reusability, are also essential to consider in estimation. [ 50 ] As of 2019 [ update ] , most of the tools for estimating the amount of time and resources for software development were designed for conventional applications and are not applicable to web applications or mobile applications . [ 51 ] Integrated development environment Anjuta , a C and C++ IDE for the GNOME environment An integrated development environment (IDE) supports software development with enhanced features compared to a simple text editor . [ 52 ] IDEs often include automated compiling , syntax highlighting of errors, [ 53 ] debugging assistance, [ 54 ] integration with version control , and semi-automation of tests. [ 52 ] Version control Main article: Version control Version control is a popular way of managing changes made to the software. Whenever a new version is checked in, the software saves a backup of all modified files. If multiple programmers are working on the software simultaneously, it manages the merging of their code changes. The software highlights cases where there is a conflict between two sets of changes and allows programmers to fix the conflict. [ 55 ] View model The TEAF Matrix of Views and Perspectives A view model is a framework that provides the viewpoints on the system and its environment , to be used in the software development process . It is a graphical representation of the underlying semantics of a view. The purpose of viewpoints and views is to enable human engineers to comprehend very complex systems and to organize the elements of the problem around domains of expertise . In the engineering of physically intensive systems, viewpoints often correspond to capabilities and responsibilities within the engineering organization. [ 56 ] Fitness functions Fitness functions are automated and objective tests to ensure that the new developments do not deviate from the established constraints, checks and compliance controls. [ 57 ] Intellectual property Intellectual property can be an issue when developers integrate open-source code or libraries into a proprietary product, because most open-source licenses used for software require that modifications be released under the same license. As an alternative, developers may choose a proprietary alternative or write their own software module. [ 58 ] References ↑ Dooley 2017 , p.   1. ↑ Dooley 2017 , p.   12. ↑ System Development Methodologies for Web-Enabled E-Business: A Customization Framework Linda V. Knight (DePaul University, USA), Theresa A. Steinbach (DePaul University, USA), and Vince Kellen (Blue Wolf, USA) ↑ Dooley 2017 , pp.   8–9. ↑ Dooley 2017 , p.   9. 1 2 Langer 2016 , pp.   2–3, 5–6. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   8. ↑ Dooley 2017 , p.   11. 1 2 Dooley 2017 , p.   13. ↑ Tucker, Morelli &amp; de Silva 2011 , pp.   41–42. 1 2 Vishnu 2019 , pp.   1–2. ↑ Laukkanen, Eero; Itkonen, Juha; Lassenius, Casper (2017). "Problems, causes and solutions when adopting continuous delivery—A systematic literature review" . Information and Software Technology . 82 : 55– 79. doi : 10.1016/j.infsof.2016.10.001 . ↑ Winters, Manshreck &amp; Wright 2020 , p.   17. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   6. ↑ Saif 2019 , pp.   46–47. ↑ Morris 2001 , p.   1.10. ↑ Langer 2016 , p.   7. ↑ Dooley 2017 , pp.   3, 8. 1 2 3 4 Langer 2016 , p.   8. ↑ Langer 2016 , pp.   2–3. ↑ Dooley 2017 , pp.   193–194. ↑ Langer 2016 , pp.   103–104. ↑ Langer 2016 , pp.   117, 127, 131, 137, 141. ↑ Langer 2016 , p.   106. ↑ Dooley 2017 , p.   142. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   31. ↑ Langer 2016 , pp.   8–9. ↑ Tucker, Morelli &amp; de Silva 2011 , pp.   31–32. ↑ Tucker, Morelli &amp; de Silva 2011 , pp.   34–35. ↑ Tucker, Morelli &amp; de Silva 2011 , pp.   31–32, 35. 1 2 3 Langer 2016 , p.   9. ↑ Dooley 2017 , p.   272. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   9. 1 2 3 Langer 2016 , p.   10. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   37. ↑ Dooley 2017 , p.   2. ↑ Winters, Manshreck &amp; Wright 2020 , pp.   30–31. ↑ "What Does a Product Manager Do? And How to Become One" . Coursera . 21 January 2025 . Retrieved 5 May 2025 . ↑ Tucker, Morelli &amp; de Silva 2011 , p.   7. ↑ Tucker, Morelli &amp; de Silva 2011 , pp.   14–15. ↑ Langer 2016 , p.   22. ↑ Langer 2016 , pp.   108–110, 206. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   243. ↑ Winters, Manshreck &amp; Wright 2020 , p.   192. ↑ Winters, Manshreck &amp; Wright 2020 , pp.   193–195. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   143. ↑ Tucker, Morelli &amp; de Silva 2011 , p.   144. ↑ Winters, Manshreck &amp; Wright 2020 , p.   204. ↑ Saif 2019 , pp.   50–51. ↑ Saif 2019 , pp.   52–53. ↑ Saif 2019 , p.   45. 1 2 Tucker, Morelli &amp; de Silva 2011 , p.   68. ↑ Dooley 2017 , p.   236. ↑ Dooley 2017 , p.   239. ↑ Dooley 2017 , pp.   246–247. ↑ Edward J. Barkmeyer ea (2003). Concepts for Automating Systems Integration Archived 25 January 2017 at the Wayback Machine NIST 2003. ↑ Fundamentals of Software Architecture: An Engineering Approach . O'Reilly Media. 2020. ISBN   978-1492043454 . ↑ Langer 2016 , pp.   44–45. Further reading Conde, Dan (2002). Software Product Management: Managing Software Development from Idea to Product to Marketing to Sales . Aspatore Books. ISBN   1587622025 . Davis, A. M. (2005). Just enough requirements management: Where software development meets marketing . Dorset House Publishing Company, Incorporated. ISBN   0932633641 . Dooley, John F. (2017). Software Development, Design and Coding: With Patterns, Debugging, Unit Testing, and Refactoring . Apress. ISBN   978-1-4842-3153-1 . Kit, Edward (1992). Software Testing in The Real World . Addison-Wesley Professional. ISBN   0201877562 . Hasted, Edward (2005). Software That Sells: A Practical Guide to Developing and Marketing Your Software Project . Wiley Publishing. ISBN   0764597833 . Hohmann, Luke (2003). Beyond Software Architecture: Creating and Sustaining Winning Solutions . Addison-Wesley Professional. ISBN   0201775948 . Horch, John W. (March 1995). "Two Orientations On How To Work With Objects". IEEE Software . 12 (2): 117– 118. ProQuest   215832531 . Langer, Arthur M. (2016). Guide to Software Development: Designing and Managing the Life Cycle . Springer. ISBN   978-1-4471-6799-0 . McCarthy, Jim (1995). Dynamics of Software Development . Microsoft Press. ISBN   1556158238 . Morris, Joseph M. (2001). Software industry accounting (2nd   ed.). John Wiley &amp; Sons . OCLC   53863959 . Rittinghouse, John (2003). Managing Software Deliverables: A Software Development Management Methodology . Digital Press. ISBN   155558313X . Saif, Syed Mohsin (2019). "Software Effort Estimation for Successful Software Application Development". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities . IGI Global . pp.   45– 97. ISBN   978-1-7998-1865-6 . Tucker, Allen; Morelli, Ralph; de Silva, Chamindra (2011). Software Development: An Open Source Approach . CRC Press. ISBN   978-1-4398-8460-7 . Vishnu, Pendyala (2019). "Evolution of Integration, Build, Test, and Release Engineering Into DevOps and to DevSecOps". In Vishnu, Pendyala (ed.). Tools and Techniques for Software Development in Large Organizations: Emerging Research and Opportunities: Emerging Research and Opportunities . IGI Global. pp.   1– 20. ISBN   978-1-7998-1865-6 . Wiegers, Karl E. (2005). More About Software Requirements: Thorny Issues and Practical Advice . Microsoft Press. ISBN   0735622671 . Winters, Titus; Manshreck, Tom; Wright, Hyrum (2020). Software Engineering at Google: Lessons Learned from Programming Over Time . O'Reilly Media, Inc. ISBN   978-1-4920-8276-7 . Wysocki, Robert K. (2006). Effective Software Project Management . Wiley. ISBN   0764596365 . External links Media related to Software development at Wikimedia Commons v t e Software engineering Fields Computer programming DevOps Empirical software engineering Experimental software engineering Formal methods Requirements engineering Search-based software engineering Site reliability engineering Social software engineering Software deployment Software design Software maintenance Software testing Systems analysis Concepts Abstraction CI/CD Compatibility Backward compatibility Compatibility layer Compatibility mode Forward compatibility Software incompatibility Component-based software engineering Data modeling Enterprise architecture Functional specification Modeling language Programming paradigm Software Software archaeology Software architecture Software configuration management Software development process/methodology Software quality Software quality assurance Software system Software verification and validation Structured analysis Essential analysis Orientations Agile Aspect-oriented Object orientation Ontology SDLC Service orientation Models Developmental Agile EUP Executable UML Incremental model Iterative model Prototype model RAD Scrum Spiral model UP V-model Waterfall model XP Model-driven engineering Round-trip engineering Other CMMI Data model ER model Function model Information model Metamodeling Object model SPICE Systems model View model Languages IDEF SysML UML USL Related fields Computer engineering Computer science Information science Project management Risk management Systems engineering Category Commons v t e Computer science Note: This template roughly follows the 2012 ACM Computing Classification System . Hardware Printed circuit board Peripheral Integrated circuit Very-large-scale integration System on a chip (SoC) Energy consumption (green computing) Electronic design automation Hardware acceleration Processor Size / Form Computer systems organization Computer architecture Computational complexity Dependability Embedded system Real-time computing Cyber-physical system Fault tolerance Wireless sensor network Networks Network architecture Network protocol Network components Network scheduler Network performance evaluation Network service Software organization Interpreter Middleware Virtual machine Operating system Software quality Software notations and tools Programming paradigm Programming language Compiler Domain-specific language Modeling language Software framework Integrated development environment Software configuration management Software library Software repository Software development Control flow Software development process Requirements analysis Software design Software construction Software deployment Software engineering Software maintenance Programming team Open-source model Theory of computation Model of computation Stochastic Formal language Automata theory Computability theory Computational complexity theory Logic Semantics Algorithms Algorithm design Analysis of algorithms Algorithmic efficiency Randomized algorithm Computational geometry Mathematics of computing Discrete mathematics Probability Statistics Mathematical software Information theory Mathematical analysis Numerical analysis Theoretical computer science Computational problem Information systems Database management system Information storage systems Enterprise information system Social information systems Geographic information system Decision support system Process control system Multimedia information system Data mining Digital library Computing platform Digital marketing World Wide Web Information retrieval Security Cryptography Formal methods Security hacker Security services Intrusion detection system Hardware security Network security Information security Application security Human-centered computing Interaction design Augmented reality Virtual reality Social computing Ubiquitous computing Visualization Accessibility Human–computer interaction Mobile computing Concurrency Concurrent computing Parallel computing Distributed computing Multithreading Multiprocessing Artificial intelligence Natural language processing Knowledge representation and reasoning Computer vision Automated planning and scheduling Search methodology Control method Philosophy of artificial intelligence Distributed artificial intelligence Machine learning Supervised learning Unsupervised learning Reinforcement learning Multi-task learning Cross-validation Graphics Animation Rendering Photograph manipulation Graphics processing unit Image compression Solid modeling Applied computing Quantum computing E-commerce Enterprise software Computational mathematics Computational physics Computational chemistry Computational biology Computational social science Computational engineering Differentiable computing Computational healthcare Digital art Electronic publishing Cyberwarfare Electronic voting Video games Word processing Operations research Educational technology Document management Specialized Platform Development Thermodynamic computing Category Outline Glossaries Authority control databases International Softwareentwicklung&lt;/span>"}]]}'> GND National United States Japan Spain Israel Other Yale LUX